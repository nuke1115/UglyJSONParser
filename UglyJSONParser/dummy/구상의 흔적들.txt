/*

operator 오버로드를 할때, 포인터의 경우는 오버로드로 따로 타입을 지정해주지 않으면, 기본적으로 bool형태로 받는다.

정수로 변환 가능한건 따로 오버로드가 없으면 bool로 변환한다
=>서로 변환 가능한 타입들끼리는 명시적인 오버로드가 없고, 넣어주는 타입에 맞는 오버로드가 없으면, 암시적으로 변환되어서 들어간다.
https://stackoverflow.com/questions/66452781/why-const-char-implicitly-converted-to-bool-rather-than-stdstring
https://en.cppreference.com/w/cpp/language/overload_resolution

표준변환, 사용자 정의 변환

---------------

https://jungwoong.tistory.com/108

---------------

트리를 어떤형태로 빌드하고, 리턴할까?

root노드 클래스를 만들고, 거기 내부에 basenode* 변수를 만들고,
빌드함수에 루트노드 인스턴스를 넣어주면, 그걸 기반으로 빌드한다?

루트노드는 단순히 첫번째 노드에 접근하는 역할만 한다.




---------------

파일 읽기//v
파일을 토큰단위로 분해//v
토큰을 기반으로 트리 생성//v

json트리를 문자열로 변환//v
파일에 쓰기//v



---------
파일 i/o시스템 만들기

토크나이저, 렉서 만들기

트리 생성기 만들기


------------


std::_Fac_node 남아있는 문제 <== std::ifstream std::ostream 

------------

ostringstream 더 알아보기
더 비효율적이면 갈아치우자

-------------

리팩토링
class private멤버변수들 앞에 _ 다 붙이기

*/


-------from tokenizer
/*
    :일 경우 //:는 무조건 object에서만 나옴
    =>indentationStack이 비어있지 않고 top이 {면서 ,왼쪽은 string타입이고, 오른쪽은 여는토큰이거나 단일value여야 한다.
    =>indentationStack이 비어있거나 top이 {이 아니거나 ,왼쪽이 string타입이 아니거나, 오른쪽이 여는토큰과 단일value 둘 다 아니라면 틀린문법.

    ,일 경우 //,는 object와 array 둘 다 나옴
    => indentationStack이 비어있지 않아야하고, 왼쪽은 닫는토큰이거나 단일 value여야 하고,
    => top이 {일때:오른쪽은 string이어야 한다.
    => top이 [일때:오른쪽은 여는토큰이거나 단일value여야한다.
    ----------
    =>만약 indentationStack이 비어있거나, 왼쪽이 닫는토큰과 단일value 둘 다 아니거나,
    => top이 {일때:오른쪽이 string이 아니면 잘못된 문법
    => top이 [일때:오른쪽이 여는토큰과 단일value 둘 다 아니면 잘못된 문법

    jsonValue일 경우
    연속되면 안됨
    =>만약 jsonValue(여는토큰들과 단일value)가 연속된다면 잘못된 문법

    */

    /*
    괄호 문법 검사 //v
    최상위 value 갯수 검사 // v
    토큰이 이상한 형태인지 검사 (:, ,: :} :] [: number : value ...) //
    */

/*
읽은 문자가 괄호 토큰들( {,},[,] ) 이것들이라면 바로 리스트에 push하고 다음문자를 읽는다.
읽은 문자가 쉼표토큰이라면 바로 리스트에 push하고 다음문자를 읽는다.
읽은 문자가 :토큰이라면 바로 리스트에 push하고 다음문자를 읽는다.

만약 문자열 플레그가 내려간 상태에서 읽은 토큰이 " 토큰이라면, 문자열 플래그를 올리고, 내부 문자열 변수 oss에 다음 " 토큰이 읽힐때까지 다른 처리과정으로 안가고, 문자열을 읽어서 oss에 더해준다.
만약 문자열 플레그가 올라간 상태에서 읽은 토큰이 "이면서 이전 토큰이 \라면 그냥 더해준다. 
    그러나,\ 다음이 바로 끝나거나, \"다음에 아무런 문자도 없으면 false리턴
만약 문자열 플레그가 올라간 상태에서 읽은 토큰이 "이라면 문자열 플레그를 내리고, oss에서 문자열을 꺼내와서 리스트에 push한다.

만약 수 플레그가 내려간 상태에서 읽은 토큰이 +,-,0~9까지의 수 중에 하나라면 수 플레그를 올리고,  ( ] , } , whitespace쪽 문자들, ,)이 읽힐때까지 문자를 읽어서 oss에 더해준다.
만약 수 플레그가 올라간 상태에서 읽은 토큰이 ( ] , } , whitespace쪽 문자들, ,) 를 제외한 json의 numbers 범위에 들어가지 않는 문자라면 무시한다.
e또는 E와 +또는 -, .의 갯수를 센다.
e또는 E가 있거나, .이 있다면 d를 oss에 더해준다.
다 읽으면 수 플레그를 내리고 검사를 시작한다.
검사
{
만약 e또는 E가 2개 이상 사용되거나, +또는 -가 3개 이상 사용되거나, .이 2개 이상 사용되면 false 리턴

부호가 있는 인덱스가 0이 아니면서 앞에 e 또는 E가 오지 않는다면 false 리턴.
부호 뒤에 수가 없다면 false 리턴.

. 양쪽에 수가 없다면 false 리턴.

e 또는 E 앞에 수가 없다면 false 리턴.
e 또는 E 뒤에 부호 또는 수가 없다면 false 리턴.


}

*/
/*

토크나이저 기능:
1:토큰화
{
문자열 입력
문자를 앞에서부터 하나씩 읽어간다.
원본 문자열의 각 토큰의 시작문자와 종료문자에 따라 모드를 바꾼다.
현제 문자와 모드에 따라서 문자열을 만들어 리스트에 넣는다.
리스트 반환

특수문자중 \붙은건 \와 특수문자 두개가 하나로 취급된다?


이스케이프처리된건, 그냥 \하고 문자를 있는 그대로 출력할까?
\" 를 "로 보여주지 말고, 있는 그대로 \" 이렇게

}
규칙:
)

}


*/
---------jsontree
/*
주석들:

Clear():
array/obj일때.
원소를 꺼내온다.
검사한다.
array/obj타입이면 그 원소를 대상으로 다시 한다.

아닐때:
그 원소를 삭제한다.
----------

만들 노드들:
SingleData
Array
Object

---------

NodeFactory

타입과 선택적으로 string을 받아서 노드를 만들어 포인터 반환

--------
null처리를 어떻게 해야될까?



1:singleData에 unknown 문자열이나 null을 데이터로 넣는다.
2:삭제한다.
3:singleData와 array,object를 멤버변수로 가지고, BaseNode를 상속받는 새로운 노드를 만들어서, 처음 실행하는 함수에 따라서 타입플레그를 설정해서 타입을 고정하는 방식으로 한다.

---------

가상소멸자가 없으면 부모노드 포인터로 자식노드 접근했을때 자식노드 소멸자 호출 안됨
이거때문에 자식노드의 소멸자가 정상적으로 호출이 안되서, 지속적으로 메모리상에 인스턴스 일부가 남아있었다.
부모노드에 가상소멸자 만들어줌으로써 해결
시간=>1시간 30분

*/
---------------

/*
빌드 방법:

전제조건: 들어오는 tokens는 tokenizer에서 토큰화와 검증이 완료된 문자열이다. (object에서의 같은 스코프에서의 중복되는 string키는 node단위에서 걸러짐)

초기설정:
첫번째 토큰으로 노드를 만들어, rootNode에 entry point로 설정한다.

그리고 루트노드를 가리키는 BaseNode* nowNode를 만들고, 루트노드의 주소를 할당한다.

그리고 그 노드가 arr/obj라면 indentationStack에 nowNode를 push한다.


루프:
iter = tokens의 이터레이터의 두번째값
iter != tokens.end()일때동안 iter++를 하며 반복

} => stack.top을 nowNode로 설정하고, stack.pop
] => stack.top을 nowNode로 설정하고, stack.pop
, => (무시하기)
: => obj일때만 => 오른쪽 토큰이 여는토큰이라면 왼쪽토큰에서 이름 가져와서 여는토큰일때의 로직 실행.
                    아니라면 왼쪽토큰에서 이름 가져와서 오른쪽 토큰 타입에 알맞는 노드 생성해서 nowNode에 createChild 실행

arr일때는 그냥 읽고 추가하기.
근데 여는 토큰 나오면 밑에 여는 토큰 나왔을때 로직으로 하고

여는토큰일때:
토큰에 맞는 타입으로 nowNode에 CreateChildNode하고, 그 포인터를 stack에 push하고 nowNode를 그 포인터로 설정

여는토큰이 아니면:
=>


이 토큰들로 해야될거같은데


*/